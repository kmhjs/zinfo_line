#
# This function parses first command name of input command query.
# Note that, this function ignores heading spaces.
#
function _zinfo_line::parse_lastcmd()
{
  local -a query=(${(s: :)${1}})

  echo ${query[1]}
}

#
# This function returns formatted date for information line
#
function _zinfo_line::formatted_date()
{
  date '+%Y/%m/%d-%H:%M:%S'
}

#
# This function returns formatted uptime information
#
function _zinfo_line::formatted_uptime()
{
  uptime | sed 's!^.*up \([0-9]*\) days.*: \([0-9. ]*\)$!{\1d, \2}!'
}

#
# This function returns macOS battery information
#
function _zinfo_line::macos_battery_info()
{
  # Here, echo reduces unnecessary linebreaks
  if [[ -x $(which pmset) ]]
  then
    echo $(pmset -g batt | egrep -wo '([0-9]*%|[0-9]*:[0-9]*)')
  fi
}

function _zinfo_line::linux_battery_info()
{
  # TODO: Clean up following task
  if [[ -x $(which acpi) ]]
  then
    acpi -b        |
      grep Battery |
      head -1      |
      sed 's/[^,]*[^0-9]*\([0-9]*%\)[^0-9]*\([0-9:]*\).*/\1 \2/g'
  fi
}

function _zinfo_line::formatted_battery_info()
{
  case ${OSTYPE} in
    darwin*) _zinfo_line::macos_battery_info ;;
    *)       _zinfo_line::linux_battery_info ;;
  esac
}

function zinfo_line()
{
    # Exceptions (Commands to be ignored)
    local -a a_exceptions=(${(s@:@)${ZMIDLINE_IGN_COMMAND}})

    # Separators
    local s_sep_head="> "
    local s_sep_date_cmd=" : "
    local s_sep_cmd_line=" "
    local right_info_separator_head="("
    local s_sep_top_batt=" / "
    local right_info_separator_tail=")"
    local s_sep_cmd_line=" "

    # Flags. Show element or not
    local -A enable_flags=(
      'last_command_info'      0
      'last_command_date_info' 0
      'acpi_info'              0
      'load_info'              0
      'middle_line'            0
      'subinfo_separator'      0
      'load-battery_separator' 0
    )

    # Get values
    ## Sent command
    local s_cmd=$(_zinfo_line::parse_lastcmd ${1})
    if [[ ${a_exceptions[(I)$s_cmd]} != 0 ]]
    then
      return 1
    fi

    ## Date string
    local s_date=$(_zinfo_line::formatted_date)

    ## Load value
    local s_load=$(_zinfo_line::formatted_uptime)

    ## battery info
    local s_acpi=$(_zinfo_line::formatted_battery_info)

    # Intialize whole line length
    local -i terminal_width=${COLUMNS}

    #
    # States
    #
    # Small
    #  |
    #  | > command
    #  | > date : command
    #  | > date : command (battery)
    #  | > date : command (load / battery)
    #  | > date : command ----- (load / battery)
    #  |
    #  V
    # Large
    #
    # * left_info  : `> date : command`
    # * right_info : `(load / battery)`
    #

    # Compute left info
    ## Compute available length and features
    terminal_width=$((${terminal_width} - ${#s_cmd} - ${#s_sep_head}))
    if (( ${terminal_width} >= 0 ))
    then
      enable_flags['last_command_info']=1
    fi

    terminal_width=$((${terminal_width} - ${#s_date} - ${#s_sep_date_cmd}))
    if (( ${terminal_width} >= 0 ))
    then
      enable_flags['last_command_date_info']=1
    fi

    ## Build left info
    local left_info=''

    if [[ ${enable_flags['last_command_info']} == 1 ]]
    then
      left_info+=${s_sep_head}
    fi

    if [[ ${enable_flags['last_command_date_info']} == 1 ]]
    then
      left_info+=${fg[gray]}${s_date}${fg[default]}${s_sep_date_cmd}
    fi

    if [[ ${enable_flags['last_command_info']} == 1 ]]
    then
      left_info+=${fg[green]}${s_cmd}${fg[default]}
    fi

    # Compute right info

    ## Compute available length and features
    if [[ -n ${s_acpi} ]]
    then
      local right_info_separator="${right_info_separator_head}${right_info_separator_tail}"
      terminal_width=$((${terminal_width} - ${#s_acpi} - ${#right_info_separator}))
      if (( ${terminal_width} >= 0 ))
      then
        enable_flags['acpi_info']=1
        enable_flags['subinfo_separator']=1
      fi
    fi

    terminal_width=$((${terminal_width} - ${#s_load} - ${#s_sep_top_batt}))
    if (( ${terminal_width} >= 0 ))
    then
      enable_flags['load_info']=1
      enable_flags['load-battery_separator']=1
    fi

    ## Build right info
    local right_info=''

    if [[ ${enable_flags['subinfo_separator']} == 1 ]]
    then
      right_info+=${right_info_separator_head}
    fi

    if [[ ${enable_flags['load_info']} == 1 ]]
    then
      right_info+=${fg[gray]}${s_load}${fg[default]}
    fi

    if [[ ${enable_flags['load-battery_separator']} == 1 ]]
    then
      right_info+=${s_sep_top_batt}
    fi

    if [[ ${enable_flags['acpi_info']} == 1 ]]
    then
      right_info+=${fg[gray]}${s_acpi}${fg[default]}
    fi

    if [[ ${enable_flags['subinfo_separator']} == 1 ]]
    then
      right_info+=${right_info_separator_tail}
    fi

    # Create separator line
    local line_separator="${s_sep_cmd_line}${s_sep_cmd_line}"
    if (( ${terminal_width} >= ${#line_separator} + 1 ))
    then
      terminal_width=$((${terminal_width} - ${#line_separator}))
      enable_flags['middle_line']=1
    fi

    local middle_line=''
    if [[ ${enable_flags['middle_line']} == 1 ]]
    then
      local s_line=${(l.${terminal_width}..-.)}
      middle_line=${s_sep_cmd_line}${fg[blue]}${s_line}${fg[default]}${s_sep_cmd_line}
    fi

    ## Show
    echo ${left_info}${middle_line}${right_info}
  }
