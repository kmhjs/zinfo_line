#
# This function parses first command name of input command query.
# Note that, this function ignores heading spaces.
#
function _zinfo_line::parse_lastcmd()
{
  local -a query=(${(s: :)${1}})

  echo ${query[1]}
}

#
# This function returns formatted date for information line
#
function _zinfo_line::formatted_date()
{
  date '+%Y/%m/%d-%H:%M:%S'
}

#
# This function returns formatted uptime information
#
function _zinfo_line::formatted_uptime()
{
  uptime | sed 's!^.*up \([0-9]*\) days.*: \([0-9. ]*\)$!{\1d, \2}!'
}

#
# This function returns macOS battery information
#
function _zinfo_line::macos_battery_info()
{
  # Here, echo reduces unnecessary linebreaks
  if [[ -x $(which pmset) ]]
  then
    echo $(pmset -g batt | egrep -wo '([0-9]*%|[0-9]*:[0-9]*)')
  fi
}

function _zinfo_line::linux_battery_info()
{
  # TODO: Clean up following task
  if [[ -x $(which acpi) ]]
  then
    acpi -b        |
      grep Battery |
      head -1      |
      sed 's/[^,]*[^0-9]*\([0-9]*%\)[^0-9]*\([0-9:]*\).*/\1 \2/g'
  fi
}

function _zinfo_line::formatted_battery_info()
{
  case ${OSTYPE} in
    darwin*) _zinfo_line::macos_battery_info ;;
    *)       _zinfo_line::linux_battery_info ;;
  esac
}

function zinfo_line()
{
    #
    # show mid line
    #

    # RESPONSIVE?
    # || > 2014/07/13-11:22:58 : ls ---------- (0.07, 0.05, 0.05 / 79% 03:22:16)
    # - (> )  s_sep_head,
    # -       s_date
    # - ( : ) s_sep_date_cmd,
    # -       s_cmd,
    # - ( )   s_sep_cmd_line,
    # - (---) s_line,
    # - ( ()  s_sep_line_sub,
    # - ( / ) s_sep_top_batt,
    # -       s_batt,
    # - ())   s_sep_batt_end

    # Values to be shown
    local s_date s_cmd s_line s_acpi

    # Separators
    local s_sep_head s_sep_date_cmd s_sep_line_sub s_sep_top_batt s_sep_batt_end s_sep_cmd_line

    # Mid line length
    local i_line_length

    # Flags. Show element or not
    local b_flags

    # Final result
    local s_status_line

    # Commands to be ignored
    local a_exceptions

    # Array for calculation
    local a_calc

    # Exceptions
    a_exceptions=($(echo $ZMIDLINE_IGN_COMMAND | tr ':' ' '))

    # Separators
    s_sep_head="> "
    s_sep_date_cmd=" : "
    s_sep_cmd_line=" "
    s_sep_line_sub=" ("
    s_sep_top_batt=" / "
    s_sep_batt_end=")"
    s_sep_cmd_line=" "

    # Init flags
    b_flags=(0 0 0 0 0 0 0)

    # Get values
    ## Sent command
    s_cmd=$(_zinfo_line::parse_lastcmd ${1})

    ## Date string
    s_date=$(_zinfo_line::formatted_date)

    ## Load value
    s_load=$(_zinfo_line::formatted_uptime)

    ## battery info
    s_acpi=$(_zinfo_line::formatted_battery_info)

    # Intialize whole line length
    i_line_length=$COLUMNS

    # Main
    if [ ${a_exceptions[(I)$s_cmd]} = 0 ]; then
        # Calculate size of each lines
        [ $(($i_line_length - $#s_cmd - $#s_sep_head)) -ge 0 ]         &&
            i_line_length=$(($i_line_length - $#s_cmd - $#s_sep_head)) &&
            b_flags[1]=1

        [ $(($i_line_length - $#s_date - $#s_sep_date_cmd)) -ge 0 ]         &&
            i_line_length=$(($i_line_length - $#s_date - $#s_sep_date_cmd)) &&
            b_flags[2]=1

        [ $s_acpi ]                                      &&
            [ $(($i_line_length - $#s_acpi)) -ge 0 ]     &&
            i_line_length=$(($i_line_length - $#s_acpi)) &&
            b_flags[3]=1

        [ $(($i_line_length - $#s_load)) -ge 0 ]         &&
            i_line_length=$(($i_line_length - $#s_load)) &&
            b_flags[4]=1

        [ $b_flags[3] = 1 -o $b_flags[4] = 1 ] &&
            i_line_length=$(($i_line_length - $#s_sep_line_sub - $#s_sep_batt_end)) &&
            b_flags[6]=1

        [ $b_flags[3] = 1 -a $b_flags[4] = 1 ]                   &&
            i_line_length=$(($i_line_length - $#s_sep_top_batt)) &&
            b_flags[7]=1

        [ $i_line_length -ge 1 ]                                 &&
            i_line_length=$(($i_line_length - $#s_sep_cmd_line)) &&
            b_flags[5]=1

        ## Create separator line
        s_line=${(l.$i_line_length..-.)}

        ## Create status bar
        s_status_line=""
        [ $b_flags[1] = 1 ] && s_status_line=${s_status_line}${s_sep_head}
        [ $b_flags[2] = 1 ] && s_status_line=${s_status_line}${fg[gray]}${s_date}${fg[default]}${s_sep_date_cmd}
        [ $b_flags[1] = 1 ] && s_status_line=${s_status_line}${fg[green]}${s_cmd}${fg[default]}
        [ $b_flags[5] = 1 ] && s_status_line=${s_status_line}${s_sep_cmd_line}${fg[blue]}${s_line}${fg[default]}
        [ $b_flags[6] = 1 ] && s_status_line=${s_status_line}${s_sep_line_sub}
        [ $b_flags[4] = 1 ] && s_status_line=${s_status_line}${fg[gray]}${s_load}${fg[default]}
        [ $b_flags[7] = 1 ] && s_status_line=${s_status_line}${s_sep_top_batt}
        [ $b_flags[3] = 1 ] && s_status_line=${s_status_line}${fg[gray]}${s_acpi}${fg[default]}
        [ $b_flags[6] = 1 ] && s_status_line=${s_status_line}${s_sep_batt_end}

        ## Show
        builtin echo $s_status_line
    fi
}
