#
# This function parses first command name of input command query.
# Note that, this function ignores heading spaces.
#
function _zinfo_line::parse_lastcmd()
{
  local -a query=(${(s: :)${1}})

  echo ${query[1]}
}

#
# This function returns formatted date for information line
#
function _zinfo_line::formatted_date()
{
  date '+%Y/%m/%d-%H:%M:%S'
}

#
# This function returns formatted uptime information
#
function _zinfo_line::formatted_uptime()
{
  uptime | sed 's!^.*up \([0-9]*\) days.*: \([0-9. ]*\)$!{\1d, \2}!'
}

#
# This function returns macOS battery information
#
function _zinfo_line::macos_battery_info()
{
  # Here, echo reduces unnecessary linebreaks
  if [[ -x $(which pmset) ]]
  then
    echo $(pmset -g batt | egrep -wo '([0-9]*%|[0-9]*:[0-9]*)')
  fi
}

function _zinfo_line::linux_battery_info()
{
  # TODO: Clean up following task
  if [[ -x $(which acpi) ]]
  then
    acpi -b        |
      grep Battery |
      head -1      |
      sed 's/[^,]*[^0-9]*\([0-9]*%\)[^0-9]*\([0-9:]*\).*/\1 \2/g'
  fi
}

function _zinfo_line::formatted_battery_info()
{
  case ${OSTYPE} in
    darwin*) _zinfo_line::macos_battery_info ;;
    *)       _zinfo_line::linux_battery_info ;;
  esac
}

function zinfo_line()
{
    #
    # show mid line
    #

    # RESPONSIVE?
    # || > 2014/07/13-11:22:58 : ls ---------- (0.07, 0.05, 0.05 / 79% 03:22:16)
    # - (> )  s_sep_head,
    # -       s_date
    # - ( : ) s_sep_date_cmd,
    # -       s_cmd,
    # - ( )   s_sep_cmd_line,
    # - (---) s_line,
    # - ( ()  s_sep_line_sub,
    # - ( / ) s_sep_top_batt,
    # -       s_batt,
    # - ())   s_sep_batt_end

    # Exceptions (Commands to be ignored)
    local -a a_exceptions=(${(s@:@)${ZMIDLINE_IGN_COMMAND}})

    # Separators
    local s_sep_head="> "
    local s_sep_date_cmd=" : "
    local s_sep_cmd_line=" "
    local s_sep_line_sub=" ("
    local s_sep_top_batt=" / "
    local s_sep_batt_end=")"
    local s_sep_cmd_line=" "

    # Flags. Show element or not
    local -a b_flags=(0 0 0 0 0 0 0)

    # Get values
    ## Sent command
    local s_cmd=$(_zinfo_line::parse_lastcmd ${1})
    if [[ ${a_exceptions[(I)$s_cmd]} != 0 ]]
    then
      return 1
    fi

    ## Date string
    local s_date=$(_zinfo_line::formatted_date)

    ## Load value
    local s_load=$(_zinfo_line::formatted_uptime)

    ## battery info
    local s_acpi=$(_zinfo_line::formatted_battery_info)

    # Intialize whole line length
    local -i terminal_width=${COLUMNS}

    # Main
    ## Calculate size of each lines
    terminal_width=$((${terminal_width} - ${#s_cmd} - ${#s_sep_head}))
    if (( ${terminal_width} >= 0 ))
    then
      b_flags[1]=1
    fi

    terminal_width=$((${terminal_width} - ${#s_date} - ${#s_sep_date_cmd}))
    if (( ${terminal_width} >= 0 ))
    then
      b_flags[2]=1
    fi

    if [[ -n ${s_acpi} ]]
    then
      terminal_width=$((${terminal_width} - ${#s_acpi}))
      if (( ${terminal_width} >= 0 ))
      then
        b_flags[3]=1
      fi
    fi

    terminal_width=$((${terminal_width} - ${#s_load}))
    if (( ${terminal_width} >= 0 ))
    then
      b_flags[4]=1
    fi

    if [[ $b_flags[3] == 1 || $b_flags[4] == 1 ]]
    then
      terminal_width=$((${terminal_width} - ${#s_sep_line_sub} - ${#s_sep_batt_end}))
      b_flags[6]=1
    fi

    if [[ $b_flags[3] == 1 && $b_flags[4] == 1 ]]
    then
      terminal_width=$((${terminal_width} - ${#s_sep_top_batt}))
      b_flags[7]=1
    fi

    if (( ${terminal_width} >= 1 ))
    then
      terminal_width=$((${terminal_width} - ${#s_sep_cmd_line}))
      b_flags[5]=1
    fi

    ## Create separator line
    local s_line=${(l.${terminal_width}..-.)}

    ## Create status bar
    local s_status_line=""

    if [[ $b_flags[1] == 1 ]]
    then
      s_status_line+=${s_sep_head}
    fi

    if [[ $b_flags[2] == 1 ]]
    then
      s_status_line+=${fg[gray]}${s_date}${fg[default]}${s_sep_date_cmd}
    fi

    if [[ $b_flags[1] == 1 ]]
    then
      s_status_line+=${fg[green]}${s_cmd}${fg[default]}
    fi

    if [[ $b_flags[5] == 1 ]]
    then
      s_status_line+=${s_sep_cmd_line}${fg[blue]}${s_line}${fg[default]}
    fi

    if [[ $b_flags[6] == 1 ]]
    then
      s_status_line+=${s_sep_line_sub}
    fi

    if [[ $b_flags[4] == 1 ]]
    then
      s_status_line+=${fg[gray]}${s_load}${fg[default]}
    fi

    if [[ $b_flags[7] == 1 ]]
    then
      s_status_line+=${s_sep_top_batt}
    fi

    if [[ $b_flags[3] == 1 ]]
    then
      s_status_line+=${fg[gray]}${s_acpi}${fg[default]}
    fi

    if [[ $b_flags[6] == 1 ]]
    then
      s_status_line+=${s_sep_batt_end}
    fi

    ## Show
    echo $s_status_line
  }
